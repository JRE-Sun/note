
<!DOCTYPE html>
<html>
  <!-- OriginalSrc: https://juejin.im/post/5c776ee4f265da2da53edfad -->
  <head>
    <meta http-equiv="Content-Type" content="text/html"; charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>【2019 前端进阶之路】Vue 组件间通信方式完整版 - 掘金@vue</title>
    
<link rel="stylesheet" href="assets/1557109778-1f9e0f727e6a99422a0a1f6e2139bd56.css">

<link rel="stylesheet" href="assets/1557109778-39cb236590c2d7f28116c42fb1c4858a.css">

<link href="assets/1557109778-883defa5388981e6f49116c12e7b8a2a.css" rel="stylesheet">
<style>
body {
        font-size: 16px;
        line-height: 2;
      }
      a, button, input {
        margin: 1rem 1.5rem;
      }
      img {
        width: 0;
        height: 0;
      }
      #juejin {
        overflow-x: hidden;
      }
</style>
<style>

</style>
<style>

:root .sidebar-bd-entry,
:root .topbanner,
:root .container > a.mid-wrapper,
:root .content > a > .topline
{ display: none !important; }
</style>
<style>
object,embed{                -webkit-animation-duration:.001s;-webkit-animation-name:playerInserted;                -ms-animation-duration:.001s;-ms-animation-name:playerInserted;                -o-animation-duration:.001s;-o-animation-name:playerInserted;                animation-duration:.001s;animation-name:playerInserted;}                @-webkit-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-ms-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-o-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}
</style>
<style>
#rwl-iqxin{position:fixed;transform:translate(-90px,0);width:85px;height:25px;font-size:12px;font-weight: 500;font-family:Verdana, Arial, '宋体';color:#fff;background:#333;z-index:2147483647;margin: 0;opacity:0.05;transition:0.3s;overflow:hidden;user-select:none;text-align:center;white-space:nowrap;line-height:25px;padding:0 16px;border:1px solid #ccc;border-width:1px 1px 1px 0;border-bottom-right-radius:5px;box-sizing: content-box;}#rwl-iqxin input{margin: 0;padding: 0;vertical-align:middle;-webkit-appearance:checkbox;-moz-appearance:checkbox;position: static;clip: auto;opacity: 1;cursor: pointer;}#rwl-iqxin.rwl-active-iqxin{left: 0px;transform:translate(0,0);opacity: 0.9;height: 32px;line-height: 32px}#rwl-iqxin label{margin:0;padding:0;font-weight:500;}#rwl-iqxin button{margin: 0;padding: 0 2px;border: none;border-radius: 2px;cursor: pointer;}#rwl-setMenu{text-align:left;font-size:14px;z-index:999999;border: 1px solid cornflowerblue;}#rwl-setMenu p{margin:5px auto;} 
</style>
<style>
#leftdiv,#rightdiv,#stickey_footer,#top_box,.ershiba,.recommend-box,.floatBottom img,.ad_float_left,body .img,.side-widget,.blog-post  .row .side,.content__tech,.bui-left.index-left{display:none!important;}<br>.box.pic_text img,#wp img,#postlist img{max-height: 400px;width: auto;}<br>.post-topheader__info--title{text-align: center;}<br>.blog-post  .row .main,.container.main-container .container,.main-area.article-area{width: 100%;max-width: 100%;}<br><br>#juejin .container{max-width:1140px;}<br><br>.container.main-container .sidebar,.container.main-container .article-suspended-panel,.global-component-box .suspension-panel{display:none!important;}<br>
</style>

    <style class="mx-wc-style">
      .mx-wc-main img {max-width: 100%;}
      .mx-wc-main{
        background-color: rgb(244, 245, 245) !important;
        margin: 0 auto;
        min-width: 100%!important;
        max-width: 100%!important;
        width: 100%!important;
        padding: 15px!important;
        box-sizing: border-box;
      }
      .mx-wc-main .single .content{border:none!important;}
      .mx-wc-main .show-content .image-package{margin-left:0!important;}
      code{white-space:pre-wrap!important;}

      .clipping-information{
        text-align: left;
        margin-top: 20px;
        background-color: #eeeeee !important;
        padding: 15px;
        border-radius: 4px;
        color: #333;
        font-size: 14px !important;
        line-height: 22px !important;
      }
      .clipping-information a {
        color: blue !important;
        text-decoration: underline !important;
      }
      .clipping-information label {
        display: inline;
        text-transform: none;
      }
      .clipping-information label > code {
        padding: 2px 8px;
        background-color: rgba(200, 200, 200, 0.7)!important;
        font-size: 14px;
      }

    </style>
  </head>
  <body style="background-color: #464646 !important;min-height:100%;min-width:100%!important;max-width:100%!important;width:100%!important; height: auto;" id="" class="">
    <div class="mx-wc-main">
      <DIV id="juejin" data-v-514f306c="" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV data-v-4b868639="" data-v-4a12c3f3="" data-v-514f306c="" class="view-container" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><MAIN data-v-4b868639="" class="container main-container" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV data-v-4a12c3f3="" data-v-4b868639="" class="view column-view" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV data-v-4a12c3f3="" data-v-4b868639="" class="main-area article-area shadow" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><ARTICLE data-v-4a12c3f3="" itemscope="itemscope" itemtype="http://schema.org/Article" class="article" data-v-4b868639="" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><div data-v-4a12c3f3="" data-id="5c981d76f265da612827667c" itemprop="articleBody" class="article-content mx-wc-selected-elem" style="float: none; position: relative; top: 0px; left: 0px; margin: 0px; flex: unset; width: 100%; max-width: 100%; box-sizing: border-box;"><h2 class="heading" data-id="heading-0">前言</h2>
<p>Vue.js 在现今使用有多广泛不用多说，而 Vue 的一大特点就是组件化。本期要讲的，便是 Vue 组件间通信方式的总结，这也几乎是近年 Vue 面试中的必考题。注：文中示例都基于 Vue 脚手架讲解，会用到一些 <a target="_blank" href="https://link.juejin.im/?target=http%3A%2F%2Felement-cn.eleme.io%2F%23%2Fzh-CN%2Fcomponent%2Finput" rel="nofollow noopener noreferrer">Element UI</a> 示例。</p>
<ul>
<li>文中示例依然在 <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwuyawei%2Fwebrtc-stream" rel="nofollow noopener noreferrer">🍧🍭😻 webrtc-stream</a></li>
<li>文章仓库 <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwuyawei%2Ffe-code" rel="nofollow noopener noreferrer">🍹🍰 fe-code</a></li>
</ul>
<p>【前端进阶之路】会作为一个新系列连载，后续会更多优质前端内容，感兴趣的同学不妨关注一下。
文章最后有 <strong>交流群</strong> 和 <strong>公众号</strong>，可以一起学习交流，感谢🍻。</p>
<ul>
<li>下期预告：深入 Vue 响应式原理，手写一个 mvvm</li>
</ul>
<h2 class="heading" data-id="heading-1">组件</h2>
<blockquote>
<p>组件是可以复用的 Vue 实例。 — <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents.html" rel="nofollow noopener noreferrer">Vue 官方文档</a>；</p>
</blockquote>
<p>在进入主题之前，还是决定先简单聊聊组件。在 Vue 中，根据注册方式的不同，可以分为：</p>
<ul>
<li>局部组件 （局部注册）</li>
<li>全局组件 （全局注册）</li>
</ul>
<p>顾名思义，全局注册的组件，可以用在 Vue 实例的任意模板中。但是带来的隐患是，在 webpack 模块化构建时，即便你没有在项目中使用这个组件，依然会打包到最终的项目代码中。而局部组件，则需要在使用到的实例中注册该组件。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-comment">// 全局注册</span>
<span class="hljs-comment">// install.js</span>
<span class="hljs-keyword">import</span> Icon <span class="hljs-keyword">from</span> <span class="hljs-string">'./Icon.vue'</span>;
<span class="hljs-keyword">const</span> install = {
    <span class="hljs-attr">install</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Vue</span>)</span>{
        Vue.component(<span class="hljs-string">'VIcon'</span>, Icon);
    }
};
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> install;
<span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> install <span class="hljs-keyword">from</span> <span class="hljs-string">'./install.js'</span>; <span class="hljs-comment">// 引入全局插件</span>
Vue.use(install); <span class="hljs-comment">// 注册</span>

<span class="hljs-comment">// 局部注册</span>
<span class="hljs-keyword">import</span> VIcon <span class="hljs-keyword">from</span> <span class="hljs-string">'./Icon.vue'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">components</span>: {
        VIcon
    }
}

<span class="hljs-comment">// 使用</span>
&lt;v-icon&gt; <span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">v-icon</span>&gt;</span>
</span><span class="copy-code-btn">复制代码</span></code></pre><p>根据应用场景的不同，又可以分为：</p>
<ul>
<li>页面组件：我们使用 Vue 时，每个路由代表的页面，都可以称之为组件。</li>
<li>基础组件：就像上面栗子中的 Icon 组件，就是一个典型的基础组件。基本上不掺杂业务逻辑，在项目中可能被大量使用，易于移植。类似的基础组件还有 Button、Input 等，常见于各类 UI 组件库。</li>
<li>业务组件：业务组件和项目具体的业务逻辑有大量耦合，一般抽离于当前项目。</li>
</ul>
<p>以上就是组件的简单介绍，那我们到底为什么要推崇组件化？组件化有什么好处？复用？我个人认为组件化最大的好处，便是解耦，易于项目管理。所以在大型项目管理中，组件化是非常有必要的。当然，这并不是今天学习的重点，以后有机会再聊。</p>
<p>正因为在 Vue 中处处都是组件，而我们也偏向于组件化、模块化。那我们在一堆组件中，便需要解决一个问题 — 组件间通信。下面，我们就进入今天的主题，Vue 的组件间通信。</p>
<h2 class="heading" data-id="heading-2">组件间通信</h2>
<p>组件间通信是我们在 Vue 项目中不可避免的问题，深刻了解了 Vue 组件间通信的几种方式，才能让我们在处理各种交互问题时游刃有余。</p>
<h3 class="heading" data-id="heading-3">Props</h3>
<p>Vue 中，最基本的通信方式就是 Props，它是父子组件通信中父组件传值给子组件的一种方式。它允许以数组形式接收，但是更推荐你开启类型检查的形式。更详细的类型检查前往 <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents-props.html" rel="nofollow noopener noreferrer">vue 文档</a>。</p>
<pre><code class="hljs html copyable" lang="html">// communication.vue
<span class="hljs-tag">&lt;<span class="hljs-name">communication-sub</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"dataProps"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
// v-bind="dataProps" 等同于 :title="title"，适用于多个参数一起传递
···
data() {
    return {
        dataProps: {
            title: '我是父组件的值',
        }
    }
}
// communication-sub.vue
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"communication-sub"</span>&gt;</span>
    {{title}}
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
···
props: ['title']
// 更推荐开启类型检查
props: {
    title: {
        type: String,
        required: true,
        default: '' // 允许指定默认值，引用类型需要函数返回
    }
}
···
<span class="copy-code-btn">复制代码</span></code></pre><p>我们都知道，Props 是单向数据流，这是 Vue 为了避免子组件意外改变父组件的状态，从而导致数据流向难以理解而做出的限制。所以 Vue 推荐需要改动的时候，通过改变父组件的值从而触发 Props 的响应。或者，我们可以在接收非引用类型的值时，使用子组件自身的 data 做一次接收。</p>
<pre><code class="hljs javascript copyable" lang="javascript">props: [<span class="hljs-string">'title'</span>],
<span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">text</span>: <span class="hljs-keyword">this</span>.title
  };
}
<span class="copy-code-btn">复制代码</span></code></pre><p>为什么是非引用类型呢，因为在 JavaScript 中，引用类型的赋值，实际是内存地址的传递。所以上面栗子中的简单赋值，显然会指向同一个内存地址，所以如果是数组或是对象，你可能需要一次深拷贝。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-keyword">let</span> obj = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj));
<span class="copy-code-btn">复制代码</span></code></pre><p>上面这个操作有一些缺陷，不能序列化函数、undefined、循环引用等，详见<a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fb084dfaad501" rel="nofollow noopener noreferrer">传送门</a>，但是也能应付一些日常情况了。</p>
<p>事实上，在 Props 是引用类型时，单独修改对象、数组的某个属性或下标，Vue 并不会抛出错误。当然，前提是你要非常清楚自己在做什么，并写好注释，防止你的小伙伴们疑惑。</p>
<p>有的同学可能知道，在组件上绑定的属性，如果没有在组件内部用 Props 声明，会默认绑定到组件的根元素上去。还是之前的栗子：</p>
<pre><code class="hljs javascript copyable" lang="javascript">&lt;communication-sub v-bind=<span class="hljs-string">"dataProps"</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"one"</span> type=<span class="hljs-string">"div"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
</span><span class="copy-code-btn">复制代码</span></code></pre><p>结果如下：</p>
<p></p><figure><img class="lazyload inited loaded" data-src="assets/1557109778-243e9a60491c30e98d51f694da6466dc" data-width="700" data-height="71" src="assets/1557109778-243e9a60491c30e98d51f694da6466dc"><figcaption></figcaption></figure><p></p>
<p>这是 Vue 默认处理的，而且，除了 class 和 style 采用合并策略，其它特性（如上栗 type）会替换掉原来根元素上的属性值。当然，我们也可以显示的在组件内部关闭掉这个特性：</p>
<pre><code class="hljs javascript copyable" lang="javascript">...
inheritAttrs: <span class="hljs-literal">false</span>,
<span class="hljs-attr">props</span>: [<span class="hljs-string">'title'</span>]
<span class="copy-code-btn">复制代码</span></code></pre><p>利用 inheritAttrs，我们还可以方便的把组件绑定的其它特性，转移到我们指定的元素上。这就需要用到下一个我们要讲的 <code>$attrs</code> 了。</p>
<h3 class="heading" data-id="heading-4">attrs、listeners</h3>
<p>我们在使用组件库的时候经常会这么写：</p>
<pre><code class="hljs javascript copyable" lang="javascript">&lt;el-input v-model=<span class="hljs-string">"input"</span> placeholder=<span class="hljs-string">"请输入内容"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">el-input</span>&gt;</span>
</span><span class="copy-code-btn">复制代码</span></code></pre><p>实际渲染后：</p>
<p></p><figure><img class="lazyload inited loaded" data-src="assets/1557109778-7c6e2422970204d765620cd72cc5443b" data-width="645" data-height="190" src="assets/1557109778-7c6e2422970204d765620cd72cc5443b"><figcaption></figcaption></figure><p></p>
<p>可以看到我们指定的的 placeholder 是渲染在 input 上的，但是 input 并不是根元素。难道都用 Props 声明后，再赋值给 input？这种情况就可以用到 <code>$attrs</code> 了，改造一下我们之前那个栗子。</p>
<pre><code class="hljs html copyable" lang="html">// communication.vue
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"communication"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">communication-sub</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"dataProps"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"input"</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">"请输入内容"</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> communicationSub <span class="hljs-keyword">from</span> <span class="hljs-string">'./communication-sub.vue'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">name</span>: <span class="hljs-string">'communication'</span>,
    data() {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">dataProps</span>: {
                <span class="hljs-attr">title</span>: <span class="hljs-string">'我是 communication 的值'</span>,
            }
        }
    },
    <span class="hljs-attr">components</span>: {
        communicationSub
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

// communication-sub.vue
···
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"communication-sub"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"title"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
···
 export default {
    inheritAttrs: false
}
<span class="copy-code-btn">复制代码</span></code></pre><p></p><figure><img class="lazyload inited" data-src="https://user-gold-cdn.xitu.io/2019/3/23/169ab45f5907f85a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" data-width="630" data-height="29" src="data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;630&quot; height=&quot;29&quot;></svg>"><figcaption></figcaption></figure><p></p>
<p>可以看到，type 已经转移到了子元素 input 标签上，但是 class 没有。这是因为 <code>inheritAttrs: false</code> 选项不会影响 style 和 class 的绑定。<strong>可以看出 <code>$attrs</code> 则是将没有被组件内部 Props 声明的传值（也叫非 Props 特性）收集起来的一个对象</strong>，再通过 v-bind 将其绑定在指定元素上。这也是 Element 等组件库采用的策略。</p>
<p><strong>这里需要注意一点，通过 $attrs 指定给元素的属性，不会与该元素原有属性发生合并或替换，而是以原有属性为准</strong>。举个例子，假如我将上述 input 的 type 默认设置为 password。</p>
<pre><code class="hljs javascript copyable" lang="javascript">&lt;input v-bind=<span class="hljs-string">"$attrs"</span> v-model=<span class="hljs-string">"title"</span> type=<span class="hljs-string">"password"</span>&gt;<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span>
<span class="copy-code-btn">复制代码</span></code></pre><p>则不会采用 $attrs 中的 type: 'text'，将以 password 为准，所以如果需要默认值的属性，建议不要用这种方式。</p>
<p><code>$listeners</code> 同 <code>$attrs</code> 类似，<strong>可以看做是一个包含了组件上所有事件监听器（包括自定义事件、不包括.native修饰的事件）的对象</strong>。它也支持上述的写法，适用于将事件安放于组件内指定元素上。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-comment">// communication.vue</span>
&lt;communication-sub v-bind=<span class="hljs-string">"dataProps"</span>
<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"input"</span>
type=<span class="hljs-string">"text"</span>
placeholder=<span class="hljs-string">"请输入内容"</span>
@focus=<span class="hljs-string">"onFocus"</span> &gt;
<span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
···
methods: {
    onFocus() {
        console.log('onFocus');
    }
}
// communication-sub.vue
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"$attrs"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"$listeners"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span>
</span><span class="copy-code-btn">复制代码</span></code></pre><p>给之前的栗子绑定一个聚焦事件，在子组件中通过 <code>$listeners</code> 绑定给 input，则会在 input 聚焦时触发。</p>
<p>那么除了用在这种给组件内指定元素绑定特性和事件的情况，还有哪些场景可以用到呢？官方说明：在创建更高层次的组件时非常有用。比如在祖孙组件中传递数据，在孙子组件中触发事件后要在祖辈中做相应更新。我们继续之前的栗子：在孙辈组件触发点击事件，然后在祖辈中修改相应的 data。</p>
<p></p><figure><img class="lazyload inited loaded" data-src="assets/1557109778-b60e4e1afa819262306e6e5f09216135.gif" data-width="1084" data-height="172" src="assets/1557109778-b60e4e1afa819262306e6e5f09216135.gif"><figcaption></figcaption></figure><p></p>
<pre><code class="hljs html copyable" lang="html">// communication.vue
<span class="hljs-tag">&lt;<span class="hljs-name">communication-sub</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"dataProps"</span>
                @<span class="hljs-attr">click</span>=<span class="hljs-string">"onCommunicationClick"</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
···
methods: {
    onCommunicationClick() {
        this.dataProps.title = '我是点击之后的值';
    }
};

// communication-sub.vue
<span class="hljs-tag">&lt;<span class="hljs-name">communication-min-sub</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"$listeners"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">communication-min-sub</span>&gt;</span> // 子组件中将事件透传到孙辈

// communication-min-sub.vue
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"communication-min-sub"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>我是 communication-min-sub<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">"$listeners"</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">name</span>: <span class="hljs-string">'communication-min-sub'</span>,
    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>这样就能很方便的在多级组件的子级组件中，快速访问到父组件的数据和方法。正如在刚才的例子中，button 点击时，是直接调用的 communication.vue 中定义的方法。</p>
<h3 class="heading" data-id="heading-5">依赖注入 provide、inject</h3>
<p>上面的方法，在大多数多级组件嵌套的场景很有用，但有时我们遇到的并不一定是有父子关系的组件。比如基础组件中的 Select 下拉选择器。</p>
<pre><code class="hljs javascript copyable" lang="javascript">&lt;el-select v-model=<span class="hljs-string">"value"</span> placeholder=<span class="hljs-string">"请选择"</span>&gt;
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">el-option</span>
      <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in options"</span>
      <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.value"</span>
      <span class="hljs-attr">:label</span>=<span class="hljs-string">"item.label"</span>
      <span class="hljs-attr">:value</span>=<span class="hljs-string">"item.value"</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">el-option</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">el-select</span>&gt;</span>
</span><span class="copy-code-btn">复制代码</span></code></pre><p>相信大家都使用过上栗或者类似于上栗的基础组件，它们借助 vue <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fcomponents-slots.html" rel="nofollow noopener noreferrer">插槽</a> 实现。所以这个时候，el-select 和 el-option 之间的数据通信，我们之前的 <code>$attrs</code>、<code>$listeners</code>就没有用武之地了。有同学可能不太理解上面的代码为什么要通信，我简单介绍一下 Element 的处理方式：</p>
<p></p><figure><img class="lazyload inited loaded" data-src="assets/1557109778-8bd37cab389cd049767d0bafd77d85b9" data-width="572" data-height="330" src="assets/1557109778-8bd37cab389cd049767d0bafd77d85b9"><figcaption></figcaption></figure><p></p>
<p>我们可以简单的认为（Element 源码比这个要稍复杂，为了方便理解，简化一下，如有需要，可直接前往源码阅读），在 el-select 中有一个 input 元素，el-option 中是一列渲染好的 li。根据需求，我们在选中某个 li 的时候，要通知 input 展示相应的数据。而且我们在实际使用的时候，一般还伴随 el-form、el-form-item等组件，所以迫切需要一种方式:</p>
<blockquote>
<p>可以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。--- <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fapi%2F%23provide-inject" rel="nofollow noopener noreferrer">Vue 文档</a></p>
</blockquote>
<p>有同学可能会想到，这种多级的可以用 Vuex、EventBus等方式，当然可以。只不过我们现在的前提是基础组件，一般第三方组件库是不会增加一些额外的依赖的。事实上 Vue 本身并不推荐直接在业务中使用 provide、inject，一般在组件、插件库用到的比较多。</p>
<p>但是在项目比较小、业务逻辑比较简单的时候，我们完全不必特意引入 Vuex。只要使用得当，provide、inject 确实不失为一种好办法。说了这么多，我们来看一下具体用法，我们将之前的栗子，改为用 provide、inject 来实现。</p>
<pre><code class="hljs html copyable" lang="html">// communication.vue
<span class="hljs-tag">&lt;<span class="hljs-name">communication-sub</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"dataProps"</span> &gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
// @click="onCommunicationClick" 移除之前绑定的时间
···
// 在 provide 添加子代需要接收的方法 onCommunicationClick，
// 也可以直接指定为 this，子代便能访问父代所有的数据和方法。
provide: function () {
    return {
        onCommunicationClick: this.onCommunicationClick
    }
},
methods: {
    onCommunicationClick() {
        this.dataProps.title = '我是点击之后的值';
    }
};

// communication-sub.vue
<span class="hljs-tag">&lt;<span class="hljs-name">communication-min-sub</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">communication-min-sub</span>&gt;</span>
// 移除之前的 v-on="$listeners"，因为在这个组件中不需要用到父组件的方法，所以不用做其它处理

// communication-min-sub.vue
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"communication-min-sub"</span>&gt;</span>
        ···
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"onCommunicationClick"</span>&gt;</span>click<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        // 移除 v-on="$listeners"，然后绑定 inject 接收到的方法
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">name</span>: <span class="hljs-string">'communication-min-sub'</span>,
    <span class="hljs-attr">inject</span>: [<span class="hljs-string">'onCommunicationClick'</span>] <span class="hljs-comment">// inject 接收父组件的方法</span>
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>这种写法和之前的 $listeners 得到的效果是一样的，就不再放图了。大家可以自己尝试一下，也可以前往源码 <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwuyawei%2Fwebrtc-stream" rel="nofollow noopener noreferrer">webrtc-stream</a>。</p>
<p><strong>思考</strong>：有些同学可能会想到，如果我在根实例，app.vue 中如此设置：</p>
<pre><code class="hljs html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    provide () {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">app</span>: <span class="hljs-keyword">this</span> <span class="hljs-comment">// 设置app为this</span>
      }
    },
    data () {
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">userInfo</span>: <span class="hljs-literal">null</span>,
        <span class="hljs-attr">otherState</span>: <span class="hljs-literal">null</span>
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>那这样把所有的状态管理都放在 app.data 中，所有的子代中不就可以共享了吗？是不是就不需要 Vuex 了呢？实际上，Vue 本身就提供了一个方法来访问根实例 <code>$root</code>，所以即使没有 provide 也是可以做到的。那为什么不这么用呢？还是前面提到的原因，不利于追踪维护，也失去了所谓状态管理的意义。不过，如果你的项目足够小的话，依然可以这么使用。</p>
<h3 class="heading" data-id="heading-6">ref、parent、children</h3>
<p>我们前面一直说的都是子组件如何触达父组件，那么父组件能不能访问到子组件呢？当然是可以的。</p>
<ul>
<li>ref</li>
</ul>
<p>简单来说就是获取元素的 Dom 对象和子组件实例。如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例。获取 Dom 元素就是为了进行一些 Dom 操作，需要注意的一点就是，<strong>要在 Dom 加载完成后使用</strong>，否则可能获取不到。比如我要将之前 input 的字体颜色改成红色：</p>
<pre><code class="hljs html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"dataProps.title"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"input"</span>&gt;</span>
...
mounted() {
    this.$nextTick(_ =&gt; { // 确保 Dom 更新完成
        this.$refs['input'].style.color = 'red';
    });
}
// 这里只是举一个栗子，实际项目中的需求，最好通过 class 的方式，尽量减少 Dom 操作。
<span class="copy-code-btn">复制代码</span></code></pre><p>那什么情况下需要获取组件实例呢？比如父元素的某个状态改变，需要子组件进行 http 请求更新数据。通常情况下，我们会选择通过 Props 将状态传递给子组件，然后子组件进行 Watch 监测，如果有变更，则进行相应操作。这个时候，我们便可以选择使用 ref。</p>
<pre><code class="hljs html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"child"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span>
···
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    methods () {
      onStateChange() { <span class="hljs-comment">// 变更状态后直接调用子组件方法进行更新</span>
          <span class="hljs-keyword">this</span>.$refs[<span class="hljs-string">'child'</span>].updateData();
      }
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><ul>
<li><code>$children</code>、<code>$parent</code></li>
</ul>
<p>无独有偶，<code>$children</code> 同样可以完成上面的任务。<code>$children</code> 和 <code>$parent</code>，顾名思义，一个会找到当前组件的子组件，一个会找到当前组件的父组件。如果有多个子组件，需要依赖组件实例的 name 属性。改写一下上面的方法：</p>
<pre><code class="hljs bash copyable" lang="bash">&lt;script&gt;
  <span class="hljs-built_in">export</span> default {
    <span class="hljs-function"><span class="hljs-title">methods</span></span> () {
      <span class="hljs-function"><span class="hljs-title">onStateChange</span></span>() { // 子组件返回的是一个数组，多个子组件用 <span class="hljs-variable">$options</span>.name 区分。
          this.<span class="hljs-variable">$children</span>[0].updateData();
      }
    }
  }
&lt;/script&gt;
<span class="copy-code-btn">复制代码</span></code></pre><p><code>$parent</code> 和 <code>$children</code> 用法一样，不过 <code>$parent</code> 返回的父组件实例，不是数组，因为父组件肯定只有一个。ref、parent、children 它们几个的一个缺点就是无法处理跨级组件和兄弟组件，后续我们会介绍 dispatch 和 broadcast 方法，实现跨级通信。</p>
<h3 class="heading" data-id="heading-7">emit、on、off</h3>
<p><code>$emit</code>，想必大家都非常熟悉，我们通常用作父子组件间通信，我们也叫它自定义事件。<code>$emit</code> 和 <code>$on</code>都是组件自身的方法，<code>$on</code> 可以监听 <code>$emit</code> 派发的事件，<code>$off</code> 则用来取消事件监听。这也是我们下一个要讲的通信方式 EventBus 所依赖的原理。</p>
<pre><code class="hljs html copyable" lang="html">// 父组件
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button-component</span> @<span class="hljs-attr">clickButton</span>=<span class="hljs-string">"clickButton"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button-component</span>&gt;</span>
    // 在父组件利用 v-on 监听
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">methods</span>: {
      clickButton () { ··· }
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

// 子组件
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleClick"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-attr">methods</span>: {
      handleClick () { <span class="hljs-comment">// 触发 $emit</span>
        <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'clickButton'</span>);
      }
    },
    mounted() {
        <span class="hljs-keyword">this</span>.$on(<span class="hljs-string">'clickButton'</span>, (...arr) =&gt; { <span class="hljs-comment">// 也可以自己监听 $emit，虽然没什么用···</span>
            <span class="hljs-built_in">console</span>.log(...arr);
        })
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><h3 class="heading" data-id="heading-8">EventBus</h3>
<p><code>$emit</code>的痛点依然是支持跨级和兄弟组件，Vue 官方推荐我们使用一个新的 Vue 实例来做一个全局的事件通信（或者叫中央事件总线···），也就是我们要讲的 EventBus。了解过的同学都知道，正常的 bus，我们一般会挂载到 Vue 的 prototype 上，方便全局调用。</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-comment">// main.js</span>
Vue.prototype.$bus = <span class="hljs-keyword">new</span> Vue();
<span class="copy-code-btn">复制代码</span></code></pre><p>依旧改写之前的栗子：</p>
<pre><code class="hljs html copyable" lang="html"><span class="hljs-comment">&lt;!--communication.vue--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">communication-sub</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">"dataProps"</span> &gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">communication-sub</span>&gt;</span>
···
beforeDestroy() { <span class="hljs-comment">&lt;!-- 实例销毁时，需要卸载监听事件 --&gt;</span>
    this.$bus.$off('busClick');
},
created() {  <span class="hljs-comment">&lt;!-- 监听子组件触发的 Bus 事件--&gt;</span>
    this.$bus.$on('busClick', (data) =&gt; {
        this.dataProps.title = data;
    });
}

<span class="hljs-comment">&lt;!--communication-min-sub.vue--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"communication-min-sub"</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"busClick"</span>&gt;</span>click bus<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-comment">&lt;!--子组件触发点击事件--&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>{
    <span class="hljs-attr">methods</span>: {
        busClick() {
            <span class="hljs-keyword">this</span>.$bus.$emit(<span class="hljs-string">'busClick'</span>, <span class="hljs-string">'bus 触发了'</span>);
        }
    }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>这是一个基础的 EventBus 的实现。现在我们设想一下，类似于 userInfo 这样的信息，在很多页面都需要用到，那我们需要在许多页面都做 <code>$on</code> 监听的操作。那能否将这些操作整合到一起呢？我们一起来看：</p>
<pre><code class="hljs javascript copyable" lang="javascript"> <span class="hljs-comment">// 新建一个 eventBus.js</span>
<span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span>;
<span class="hljs-keyword">const</span> bus = <span class="hljs-keyword">new</span> Vue({
    data () {
        <span class="hljs-keyword">return</span> {
            <span class="hljs-attr">userInfo</span>: {}
        }
    },
    created () {
        <span class="hljs-keyword">this</span>.$on(<span class="hljs-string">'getUserInfo'</span>, val =&gt; {
            <span class="hljs-keyword">this</span>.userInfo = val;
        })
    }
});
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> bus;
<span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">'./eventBus'</span>;
Vue.prototype.$bus = bus;
<span class="hljs-comment">// app.vue</span>
methods: {
    getUserInfo() {
        ajax.post(***).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> {
            <span class="hljs-keyword">this</span>.$bus.$emit(<span class="hljs-string">'getUserInfo'</span>, data); <span class="hljs-comment">// 通知 EventBus 更新 userInfo</span>
        })
    }
}
<span class="copy-code-btn">复制代码</span></code></pre><p>这样在其他页面用到 userInfo 的时候，只需要 <code>this.$bus.userInfo</code> 就可以了。注意刚刚其实没有用 off 卸载掉监听，因为其实 userInfo 这种全局信息，并没有一个准确的说要销毁的时机，浏览器关闭的时候，也用不着我们处理了。但是，如果只是某个页面组件用到的，建议还是用最开始的方法，在页面销毁的时候卸载掉。</p>
<p>不过反过来讲，既然用到了 EventBus，说明状态管理并不复杂，否则还是建议用 Vuex 来做。最后再给大家推荐一篇文章 <a target="_blank" href="https://juejin.im/post/5b45971ff265da0f9c678b55" rel="">Vue中eventbus很头疼？我来帮你</a>，作者处理 EventBus 的思路很巧妙，大家不妨仔细看看。</p>
<h3 class="heading" data-id="heading-9">派发与广播：dispatch 与 broadcast</h3>
<blockquote>
<p>此部分参考自 <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fblob%2Fdev%2Fsrc%2Fmixins%2Femitter.js" rel="nofollow noopener noreferrer">Element 源码</a></p>
</blockquote>
<p>在 Vue 1.x 的实现中，有 <code>$dispatch</code> 和 <code>$broadcast</code> 方法，但是在 2.x 被废弃了。<code>$dispatch</code> 的主要作用是向上级组件派发事件，<code>$broadcast</code> 则是向下级广播。它们的优点是都支持跨级，再看一下官方废弃这两个方法的理由：</p>
<blockquote>
<p>因为基于组件树结构的事件流方式实在是让人难以理解，并且在组件结构扩展的过程中会变得越来越脆弱。并且 <code>$dispatch</code> 和 <code>$broadcast</code> 也没有解决兄弟组件间的通信问题。</p>
</blockquote>
<p>可以看到，主要原因是在组件结构扩展后不易理解，以及没有解决兄弟组件通信的问题。但是对于组件库来说，这依旧是十分有用的，所以它们大多自己实现了这两个方法。对我们来讲，也许在项目中用不到，但学习这种解决问题的思路，是十分必要的。</p>
<p>派发和广播，依赖于组件的 name（最怕此处有人说：如果不写 name，这方法不就没用了？2333···），以此来逐级查找对应的组件实例。Element 的实现中，给所有的组件都加了一个 componentName 属性，所以它是根据 componentName 来查找的。我们在实现的时候还是直接用 name。</p>
<p>我们先来看一下 <code>$dispatch</code> 的简单用法，再来分析思路。</p>
<pre><code class="hljs html copyable" lang="html"><span class="hljs-comment">&lt;!--communication-min-sub.vue--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"handleDispatch"</span>&gt;</span>dispatch<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
<span class="hljs-keyword">import</span> Emitter <span class="hljs-keyword">from</span> <span class="hljs-string">'../../utils/emitter'</span>;
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">mixins</span>: [Emitter], <span class="hljs-comment">// 混入，方便直接调用</span>
  methods: {
    handleDispatch () {
      <span class="hljs-keyword">this</span>.dispatch(<span class="hljs-string">'communication'</span>, <span class="hljs-string">'onMessage'</span>, <span class="hljs-string">'触发了dispatch'</span>);
    }
  }
}
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><pre><code class="hljs html copyable" lang="html"><span class="hljs-comment">&lt;!--communication.vue--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    beforeDestroy() { <span class="hljs-comment">// 销毁</span>
        <span class="hljs-keyword">this</span>.$off(<span class="hljs-string">'onMessage'</span>);
    },
    mounted () {
        <span class="hljs-keyword">this</span>.$on(<span class="hljs-string">'onMessage'</span>, (data) =&gt; { <span class="hljs-comment">// 监听</span>
            <span class="hljs-keyword">this</span>.dataProps.title = data;
        })
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>现在明确一下目标，dispatch 方法接收三个参数，组件 name、事件名称、基础数据（可不传）。要做到向上跨级派发事件，需要向上找到指定 name 的组件实例，利用我们前文提到的 <code>$emit</code>方法做派送，所以在指定组件就可以用 <code>$on</code> 来监听了。所以 dispatch 本质上就是向上查找到指定组件并触发其自身的 <code>$emit</code>，以此来做响应，broadcast 则相反。那么如何做到跨级查找呢？</p>
<pre><code class="hljs javascript copyable" lang="javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">broadcast</span>(<span class="hljs-params">componentName, eventName, params</span>) </span>{
  <span class="hljs-keyword">this</span>.$children.forEach(<span class="hljs-function"><span class="hljs-params">child</span> =&gt;</span> { <span class="hljs-comment">// 遍历所有的 $children</span>
    <span class="hljs-keyword">var</span> name = child.$options.name; <span class="hljs-comment">// 拿到实例的name，Element 此处用的 componentName</span>
    <span class="hljs-keyword">if</span> (name === componentName) { <span class="hljs-comment">// 如果是想要的那个，进行广播</span>
      child.$emit.apply(child, [eventName].concat(params));
    } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 不是则递归查找 直到 $children 为 []</span>
      broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
  <span class="hljs-attr">methods</span>: {
    dispatch(componentName, eventName, params) {
      <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>.$parent || <span class="hljs-keyword">this</span>.$root;
      <span class="hljs-keyword">var</span> name = parent.$options.name;
      <span class="hljs-keyword">while</span> (parent &amp;&amp; (!name || name !== componentName)) {
      <span class="hljs-comment">// 存在 parent 且 (不存在 name 或 name 和 指定参数不一样) 则继续查找</span>
        parent = parent.$parent; <span class="hljs-comment">// 不存在继续取上级</span>
        <span class="hljs-keyword">if</span> (parent) {
          name = parent.$options.name; <span class="hljs-comment">// 存在上级 再次赋值并再次循环，进行判断</span>
        }
      }
      <span class="hljs-keyword">if</span> (parent) { <span class="hljs-comment">// 找到以后 如果有 进行事件派发</span>
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },
    broadcast(componentName, eventName, params) {
      broadcast.call(<span class="hljs-keyword">this</span>, componentName, eventName, params);
    }
  }
};
<span class="copy-code-btn">复制代码</span></code></pre><p>以上是详细的 emitter.js，可以看见，这和我们之前讲到的 <code>$parent</code>、<code>$children</code>、<code>$emit</code>、<code>$on</code>都密切相关。这也是为什么把它放到后面讲的原因。之前说过，派发和广播并没有解决兄弟组件通信的问题，所以这里大家也可以拓展思考一下，如何支持兄弟组件间通信。依然是依赖于<code>$parent</code>、<code>$children</code>，可以找到任意指定组件。</p>
<h3 class="heading" data-id="heading-10">Vuex</h3>
<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。--- <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fvuex.vuejs.org%2Fzh%2F" rel="nofollow noopener noreferrer">官方文档</a></p>
</blockquote>
<p>Vuex 相信大家都比较熟悉了，我不打算在这里把 API 再演示一遍。因为我觉得，官方文档 已经非常详细了。Vuex 的核心是单向数据流，并以相应规则保证所有的状态管理都可追踪、可预测。</p>
<p>我们需要知道什么时候该用 Vuex，如果你的项目比较小，状态管理比较简单，完全没有必要使用 Vuex，你可以考虑我们前文提到的几种方式。</p>
<h2 class="heading" data-id="heading-11">总结</h2>
<p>本期文章内容到这里就讲完了，我们来总结回顾一下：</p>
<ul>
<li>子组件触达父组件的方式：Props、<code>$parent</code>、<code>$attrs</code>、<code>$listeners</code>、provide 和 inject、<code>$dispatch</code></li>
<li>父组件触达子组件的方式：<code>$emit</code> 和 <code>$on</code>、<code>$children</code>、<code>$ref</code>、<code>broadcast</code></li>
<li>全局通信：EventBus、Vuex</li>
</ul>
<p>本来想按照是否支持跨级来分，但是这里的界定比较模糊：如果逐级传递，有些也能做到跨级，但这并不是我们想要的。所以我们只要自己清楚在什么情况下该怎么用就好了。</p>
<h2 class="heading" data-id="heading-12">交流群</h2>
<blockquote>
<p>qq前端交流群：960807765，欢迎各种技术交流，期待你的加入</p>
</blockquote>
<h2 class="heading" data-id="heading-13">后记</h2>
<p>如果你看到了这里，且本文对你有一点帮助的话，希望你可以动动小手支持一下作者，感谢🍻。文中如有不对之处，也欢迎大家指出，共勉。</p>
<ul>
<li>本文示例 <strong>源码库</strong> <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwuyawei%2Fwebrtc-stream" rel="nofollow noopener noreferrer">webrtc-stream</a></li>
<li><strong>文章仓库</strong> <a target="_blank" href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fwuyawei%2Ffe-code" rel="nofollow noopener noreferrer">🍹🍰fe-code</a></li>
</ul>
<p>更多文章：</p>
<ul>
<li><a target="_blank" href="https://juejin.im/post/5c7b524ee51d453ee81877a7" rel="">【2019 前端进阶之路】JavaScript 原型和原型链及 canvas 验证码实践</a></li>
<li><a target="_blank" href="https://juejin.im/post/5c179aad5188256d9832fb61" rel="">【2019 前端进阶之路】站住，你这个Promise！</a></li>
<li><a target="_blank" href="https://juejin.im/post/5c3acfa56fb9a049f36254be" rel="">【从头到脚】撸一个多人视频聊天 — 前端 WebRTC 实战（一）</a></li>
<li><a target="_blank" href="https://juejin.im/post/5c0a00fb6fb9a049d4419d3a" rel="">【从头到脚】撸一个社交聊天系统（vue + node + mongodb）- 💘🍦🙈Vchat </a></li>
</ul>
<p>欢迎关注公众号 <strong>前端发动机</strong>，第一时间获得作者文章推送，还有各类前端优质文章，希望在未来的前端路上，与你一同成长。</p>
<p></p><figure><img class="lazyload inited loaded" data-src="assets/1557109778-86e62daa38d084fcc2af50d9e4fbe462" data-width="258" data-height="258" src="assets/1557109778-86e62daa38d084fcc2af50d9e4fbe462"><figcaption></figcaption></figure><p></p>
</div></ARTICLE></DIV></DIV></MAIN></DIV></DIV>
      
        <hr />
        <!-- clipping information -->
        <div class="clipping-information">
          <label>原网址: <a href="https://juejin.im/post/5c776ee4f265da2da53edfad" target="_blank" referrerpolicy="no-referrer" rel="noopener noreferrer">访问</a></label><br />
          <label>创建于: 2019-05-06 10:29:38</label><br />
          <label>目录: default</label><br />
          <label>标签: 无</label>
        </div>
    </div>
  </body>
</html>