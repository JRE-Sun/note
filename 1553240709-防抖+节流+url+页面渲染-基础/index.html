
<!DOCTYPE html>
<html>
  <!-- OriginalSrc: https://github.com/LiangJunrong/document-library/blob/master/other-library/Interview/PersonalExperience/JS-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.md -->
  <head>
    <meta http-equiv="Content-Type" content="text/html"; charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <title>防抖+节流+url+页面渲染-基础</title>
    
<link media="all" rel="stylesheet" href="assets/1553242691-f73b1d2657b9181d5349ff21b57cce50.css">

<link media="all" rel="stylesheet" href="assets/1553242691-11166bb9730f7378d8864b8dcd4c7eeb.css">
<style>

html.cye-enabled.cye-nm:not(*:-webkit-full-screen) body,
 html.cye-enabled.cye-nm:not(*:-webkit-full-screen) #cye-workaround-body {-webkit-filter:contrast(91%) brightness(84%) invert(1);}
</style>
<style>
html.cye-enabled.cye-lm body{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>
html.cye-enabled.cye-lm div{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>
html.cye-enabled.cye-lm th{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm td{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>
html.cye-enabled.cye-lm input[type=text]{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}html.cye-enabled.cye-lm textarea{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>
html.cye-enabled.cye-lm select{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>
html.cye-enabled.cye-lm ul{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>
html.cye-enabled.cye-lm .cye-lm-tag,html.cye-enabled.cye-lm.cye-lm-tag{background-color:#cce8cf !important;border-color:rgb(51, 58, 51) !important;background-image:none !important;color:#000000  !important}
</style>
<style>

</style>
<style>
object,embed{                -webkit-animation-duration:.001s;-webkit-animation-name:playerInserted;                -ms-animation-duration:.001s;-ms-animation-name:playerInserted;                -o-animation-duration:.001s;-o-animation-name:playerInserted;                animation-duration:.001s;animation-name:playerInserted;}                @-webkit-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-ms-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @-o-keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}                @keyframes playerInserted{from{opacity:0.99;}to{opacity:1;}}
</style>
<style>
#rwl-iqxin{position:fixed;transform:translate(-90px,0);width:85px;height:25px;font-size:12px;font-weight: 500;font-family:Verdana, Arial, '宋体';color:#fff;background:#333;z-index:2147483647;margin: 0;opacity:0.05;transition:0.3s;overflow:hidden;user-select:none;text-align:center;white-space:nowrap;line-height:25px;padding:0 16px;border:1px solid #ccc;border-width:1px 1px 1px 0;border-bottom-right-radius:5px;box-sizing: content-box;}#rwl-iqxin input{margin: 0;padding: 0;vertical-align:middle;-webkit-appearance:checkbox;-moz-appearance:checkbox;position: static;clip: auto;opacity: 1;cursor: pointer;}#rwl-iqxin.rwl-active-iqxin{left: 0px;transform:translate(0,0);opacity: 0.9;height: 32px;line-height: 32px}#rwl-iqxin label{margin:0;padding:0;font-weight:500;}#rwl-iqxin button{margin: 0;padding: 0 2px;border: none;border-radius: 2px;cursor: pointer;}#rwl-setMenu{text-align:left;font-size:14px;z-index:999999;border: 1px solid cornflowerblue;}#rwl-setMenu p{margin:5px auto;} 
</style>
<style>
#leftdiv,#rightdiv,#stickey_footer,#top_box,.ershiba,.recommend-box,.floatBottom img,.ad_float_left,body .img,.side-widget,.blog-post  .row .side,.content__tech{display:none!important;}<br>.box.pic_text img,#wp img,#postlist img{max-height: 400px;width: auto;}<br>.post-topheader__info--title{text-align: center;}<br>.blog-post  .row .main,.container.main-container .container,.main-area.article-area{width: 100%;max-width: 100%;}<br><br>#juejin .container{max-width:1140px;}<br><br>.container.main-container .sidebar,.container.main-container .article-suspended-panel,.global-component-box .suspension-panel{display:none!important;}
</style>

    <style class="mx-wc-style">
      .mx-wc-main img {max-width: 100%;}
      .mx-wc-main{
        box-sizing: content-box;
        background-color: rgb(255, 255, 255) !important;
        margin: 0 auto;
        max-width: 980px;
        padding: 15px 15px 80px 15px;
      }

      .clipping-information{
        text-align: left;
        margin-top: 20px;
        background-color: #eeeeee !important;
        padding: 15px;
        border-radius: 4px;
        color: #333;
        font-size: 14px !important;
        line-height: 22px !important;
      }
      .clipping-information a {
        color: blue !important;
        text-decoration: underline !important;
      }
      .clipping-information label {
        display: inline;
        text-transform: none;
      }
      .clipping-information label > code {
        padding: 2px 8px;
        background-color: rgba(200, 200, 200, 0.7)!important;
        font-size: 14px;
      }

    </style>
  </head>
  <body style="background-color: #464646 !important; min-height: 100%; height: auto;" id="" class="logged-in env-production emoji-size-boost page-blob">
    <div class="mx-wc-main">
      <DIV class="application-main " data-commit-hovercards-enabled="" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV itemscope="" itemtype="http://schema.org/SoftwareSourceCode" class="" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><MAIN id="js-repo-pjax-container" data-pjax-container="" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV class="container new-discussion-timeline experiment-repo-nav  " style="margin-left: 10px;display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV class="repository-content " style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV class="Box mt-3 position-relative" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><DIV id="readme" class="Box-body readme blob instapaper_body js-code-block-container" style="display: block; float: none; position: relative; top: 0; left: 0; border: 0px; width: 100%; min-width:100%; max-width: 100%; min-height: auto; max-height: 100%; height: auto; padding: 0px; margin: 0px;"><article class="markdown-body entry-content p-5 mx-wc-selected-elem" itemprop="text" style="float: none; position: relative; top: 0px; left: 0px; margin: 0px; flex: unset; width: 100%; max-width: 100%; box-sizing: border-box;"><h1><a id="user-content-面试知识点---js-防抖与节流" class="anchor" aria-hidden="true" href="#%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9---js-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"></a>面试知识点 - JS 防抖与节流</h1>
<blockquote>
<p>Create by <strong>jsliang</strong> on <strong>2019-2-23 20:55:34</strong><br>
Recently revised in <strong>2019-3-12 22:46:04</strong></p>
</blockquote>
<p><strong>Hello 小伙伴们，如果觉得本文还不错，记得给个 <strong>star</strong> ， 你们的 <strong>star</strong> 是我学习的动力！<a href="https://github.com/LiangJunrong/document-library/blob/master/other-library/Interview/PersonalExperience/JS-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.md">GitHub 地址</a></strong></p>
<p><strong>本文涉及知识点</strong>：</p>
<ul>
<li><strong>防抖与节流</strong></li>
<li><strong>重绘与回流</strong></li>
<li><strong>浏览器解析 URL</strong></li>
<li><strong>DNS 域名解析</strong></li>
<li><strong>TCP 三次握手与四次挥手</strong></li>
<li><strong>浏览器渲染页面</strong></li>
</ul>
<p><strong>在本文中，jsliang 会讲解通过自我探索后关于上述知识点的个人理解，如有纰漏、疏忽或者误解，欢迎各位小伙伴留言指出。</strong></p>
<blockquote>
<p>如果小伙伴对文章存有疑问，想快速得到回复。<br>
或者小伙伴对 jsliang 个人的前端文档库感兴趣，也想将自己的前端知识整理出来。<br>
欢迎加 QQ 群一起探讨：<code>798961601</code>。</p>
</blockquote>
<h2><a id="user-content-一-目录" class="anchor" aria-hidden="true" href="#%E4%B8%80-%E7%9B%AE%E5%BD%95"></a><a name="user-content-chapter-one" id="user-content-chapter-one">一 目录</a></h2>
<p><strong>不折腾的前端，和咸鱼有什么区别</strong></p>
<table>
<thead>
<tr>
<th>目录</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="#chapter-one">一 目录</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-two" id="user-content-catalog-chapter-two"></a><a href="#chapter-two">二 前言</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-three" id="user-content-catalog-chapter-three"></a><a href="#chapter-three">三 防抖与节流</a></td>
</tr>
<tr>
<td> <a href="#chapter-three-one">3.1 防抖</a></td>
</tr>
<tr>
<td> <a href="#chapter-three-two">3.2 节流</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-four" id="user-content-catalog-chapter-four"></a><a href="#chapter-four">四 重绘与回流</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-five" id="user-content-catalog-chapter-five"></a><a href="#chapter-five">五 浏览器解析 URL</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-six" id="user-content-catalog-chapter-six"></a><a href="#chapter-six">六  DNS 域名解析</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-seven" id="user-content-catalog-chapter-seven"></a><a href="#chapter-seven">七 TCP 三次握手与四次挥手</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-eight" id="user-content-catalog-chapter-eight"></a><a href="#chapter-eight">八 浏览器渲染页面</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-night" id="user-content-catalog-chapter-night"></a><a href="#chapter-night">九 总结</a></td>
</tr>
<tr>
<td><a name="user-content-catalog-chapter-ten" id="user-content-catalog-chapter-ten"></a><a href="#chapter-ten">十 参考文献</a></td>
</tr>
</tbody>
</table>
<h2><a id="user-content-二-前言" class="anchor" aria-hidden="true" href="#%E4%BA%8C-%E5%89%8D%E8%A8%80"></a><a name="user-content-chapter-two" id="user-content-chapter-two">二 前言</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p>在工作中，我们可能碰到这样的问题：</p>
<ul>
<li>用户在搜索的时候，在不停敲字，如果每敲一个字我们就要调一次接口，接口调用太频繁，给卡住了。</li>
<li>用户在阅读文章的时候，我们需要监听用户滚动到了哪个标题，但是每滚动一下就监听，那样会太过频繁从而占内存，如果再加上其他的业务代码，就卡住了。</li>
</ul>
<p>所以，这时候，我们就要用到 <strong>防抖与节流</strong> 了。</p>
<p>那么，讲到 <strong>防抖与节流</strong>，我们可以顺带探秘下 <strong>重绘与回流</strong>。</p>
<p>说起 <strong>重绘与回流</strong>，我们就顺带把 <strong>浏览器输入 URL 后发生的事情</strong> 也关注一下，从而引出 <strong>DNS</strong>、<strong>TCP</strong> 等知识点，最终串起来构成本文的轮廓，方便 <strong>jsliang</strong> 和小伙伴们对这块知识的整理与记忆。</p>
<h2><a id="user-content-三-防抖与节流" class="anchor" aria-hidden="true" href="#%E4%B8%89-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"></a><a name="user-content-chapter-three" id="user-content-chapter-three">三 防抖与节流</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p><strong>通过代码去了解某样事物，往往是了解某个知识点最快的形式。</strong></p>
<h3><a id="user-content-31-防抖" class="anchor" aria-hidden="true" href="#31-%E9%98%B2%E6%8A%96"></a><a name="user-content-chapter-three-one" id="user-content-chapter-three-one">3.1 防抖</a></h3>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p>下面我们有段防抖小案例代码。</p>
<p>如果小伙伴们手头有电脑，并感兴趣想先自己思考下什么是防抖。可以将代码复制到浏览器，尝试点击按钮，并关注下控制台，看看 Console 是如何打印的。</p>
<p>如果小伙伴们手头没有电脑，那么咱一起先瞅瞅代码实现，再看看下面 GIF 演示。（这样效果没有自己敲的直白有效）</p>
<div class="highlight highlight-text-html-basic"><pre>&lt;!DOCTYPE html&gt;
&lt;<span class="pl-ent">html</span> <span class="pl-e">lang</span>=<span class="pl-s"><span class="pl-pds">"</span>en<span class="pl-pds">"</span></span>&gt;
&lt;<span class="pl-ent">head</span>&gt;
  &lt;<span class="pl-ent">meta</span> <span class="pl-e">charset</span>=<span class="pl-s"><span class="pl-pds">"</span>UTF-8<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">meta</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>viewport<span class="pl-pds">"</span></span> <span class="pl-e">content</span>=<span class="pl-s"><span class="pl-pds">"</span>width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">meta</span> <span class="pl-e">http-equiv</span>=<span class="pl-s"><span class="pl-pds">"</span>X-UA-Compatible<span class="pl-pds">"</span></span> <span class="pl-e">content</span>=<span class="pl-s"><span class="pl-pds">"</span>ie=edge<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">title</span>&gt;防抖&lt;/<span class="pl-ent">title</span>&gt;
&lt;/<span class="pl-ent">head</span>&gt;
&lt;<span class="pl-ent">body</span>&gt;
  &lt;<span class="pl-ent">button</span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>debounce<span class="pl-pds">"</span></span>&gt;点我防抖！&lt;/<span class="pl-ent">button</span>&gt;

  &lt;<span class="pl-ent">script</span>&gt;<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c1">window</span>.<span class="pl-en">onload</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {</span>
<span class="pl-s1">      <span class="pl-c"><span class="pl-c">//</span> 1、获取这个按钮，并绑定事件</span></span>
<span class="pl-s1">      <span class="pl-k">var</span> myDebounce <span class="pl-k">=</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>(<span class="pl-s"><span class="pl-pds">"</span>debounce<span class="pl-pds">"</span></span>);</span>
<span class="pl-s1">      <span class="pl-smi">myDebounce</span>.<span class="pl-c1">addEventListener</span>(<span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-en">debounce</span>(sayDebounce));</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c"><span class="pl-c">//</span> 2、防抖功能函数，接受传参</span></span>
<span class="pl-s1">    <span class="pl-k">function</span> <span class="pl-en">debounce</span>(<span class="pl-smi">fn</span>) {</span>
<span class="pl-s1">      <span class="pl-c"><span class="pl-c">//</span> 4、创建一个标记用来存放定时器的返回值</span></span>
<span class="pl-s1">      <span class="pl-k">let</span> timeout <span class="pl-k">=</span> <span class="pl-c1">null</span>;</span>
<span class="pl-s1">      <span class="pl-k">return</span> <span class="pl-k">function</span>() {</span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 5、每次当用户点击/输入的时候，把前一个定时器清除</span></span>
<span class="pl-s1">        <span class="pl-c1">clearTimeout</span>(timeout);</span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 6、然后创建一个新的 setTimeout，</span></span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 这样就能保证点击按钮后的 interval 间隔内</span></span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 如果用户还点击了的话，就不会执行 fn 函数</span></span>
<span class="pl-s1">        timeout <span class="pl-k">=</span> <span class="pl-c1">setTimeout</span>(() <span class="pl-k">=&gt;</span> {</span>
<span class="pl-s1">          <span class="pl-smi">fn</span>.<span class="pl-c1">call</span>(<span class="pl-c1">this</span>, <span class="pl-c1">arguments</span>);</span>
<span class="pl-s1">        }, <span class="pl-c1">1000</span>);</span>
<span class="pl-s1">      };</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c"><span class="pl-c">//</span> 3、需要进行防抖的事件处理</span></span>
<span class="pl-s1">    <span class="pl-k">function</span> <span class="pl-en">sayDebounce</span>() {</span>
<span class="pl-s1">      <span class="pl-c"><span class="pl-c">//</span> ... 有些需要防抖的工作，在这里执行</span></span>
<span class="pl-s1">      <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">"</span>防抖成功！<span class="pl-pds">"</span></span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">  </span>&lt;/<span class="pl-ent">script</span>&gt;
&lt;/<span class="pl-ent">body</span>&gt;
&lt;/<span class="pl-ent">html</span>&gt;</pre></div>
<p>很好，相信小伙伴们已经看完了代码，下面我们看看它的演示：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-1.gif"><img src="assets/1553242691-53bf0e5bf8b63119f83f8c0713fe18bd.gif" alt="图" style="max-width:100%;"></a></p>
<p>这时候，我们可以抛出防抖的概念了：</p>
<ul>
<li><strong>防抖</strong>：<strong>任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。</strong></li>
</ul>
<p>结合上面的代码，我们可以了解到，在触发点击事件后，如果用户再次点击了，我们会清空之前的定时器，重新生成一个定时器。意思就是：这件事儿需要等待，如果你反复催促，我就重新计时！</p>
<p>空讲无益，show you 场景：</p>
<ul>
<li>有个输入框，输入之后会调用接口，获取联想词。但是，因为频繁调用接口不太好，所以我们在代码中使用防抖功能，只有在用户输入完毕的一段时间后，才会调用接口，出现联想词。</li>
</ul>
<p>小伙伴们可以尝试看着上面的案例，先自己实现一遍这个场景的解决，如果感觉不行，那就看：<a href="https://www.codercto.com/a/35263.html" rel="nofollow">《防抖和节流的应用场景和实现》</a></p>
<blockquote>
<p>知识点补充：何为 <code>arguments</code>？<br>
<strong>首先</strong>，后端转前端的同学，可以将 <code>arguments</code> 理解为能实现重载函数功能的工具。<br>
<strong>然后</strong>，我们举个例子：在 <code>function test()</code> 这个方法中，由于我们不确定变量有多少，比如 <code>test("jsliang", 24)</code>，又或者 <code>test("LiangJunrong", "jsliang", "24")</code>，这时候只需要在函数 <code>test</code> 中用 <code>arguments</code> 接收就行了。<br>
<strong>最后</strong>，在 <code>function test() { let arr1 = argument[0] }</code> 中，<code>arr1</code> 就可以获取到传进来的第一个变量。<br>
<strong>所以</strong>，<code>fn.call(this, arguments)</code> 其实是将不确定变量替换到函数中了。</p>
</blockquote>
<blockquote>
<p>参考资料 1：<a href="https://www.cnblogs.com/alai88/p/5518441.html" rel="nofollow">《闲聊 JS 中的 apply 和 call》</a><br>
参考资料 2：<a href="https://www.cnblogs.com/LMJBlogs/p/6024148.html" rel="nofollow">《js 中 arguments 的用法》</a></p>
</blockquote>
<h3><a id="user-content-32-节流" class="anchor" aria-hidden="true" href="#32-%E8%8A%82%E6%B5%81"></a><a name="user-content-chapter-three-two" id="user-content-chapter-three-two">3.2 节流</a></h3>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p>说完防抖，下面我们讲讲节流，规矩就不说了，先上代码：</p>
<div class="highlight highlight-text-html-basic"><pre>&lt;!DOCTYPE html&gt;
&lt;<span class="pl-ent">html</span> <span class="pl-e">lang</span>=<span class="pl-s"><span class="pl-pds">"</span>en<span class="pl-pds">"</span></span>&gt;
&lt;<span class="pl-ent">head</span>&gt;
  &lt;<span class="pl-ent">meta</span> <span class="pl-e">charset</span>=<span class="pl-s"><span class="pl-pds">"</span>UTF-8<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">meta</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>viewport<span class="pl-pds">"</span></span> <span class="pl-e">content</span>=<span class="pl-s"><span class="pl-pds">"</span>width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">meta</span> <span class="pl-e">http-equiv</span>=<span class="pl-s"><span class="pl-pds">"</span>X-UA-Compatible<span class="pl-pds">"</span></span> <span class="pl-e">content</span>=<span class="pl-s"><span class="pl-pds">"</span>ie=edge<span class="pl-pds">"</span></span>&gt;
  &lt;<span class="pl-ent">title</span>&gt;节流&lt;/<span class="pl-ent">title</span>&gt;
&lt;/<span class="pl-ent">head</span>&gt;
&lt;<span class="pl-ent">body</span>&gt;

  &lt;<span class="pl-ent">button</span> <span class="pl-e">id</span>=<span class="pl-s"><span class="pl-pds">"</span>throttle<span class="pl-pds">"</span></span>&gt;点我节流！&lt;/<span class="pl-ent">button</span>&gt;

  &lt;<span class="pl-ent">script</span>&gt;<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c1">window</span>.<span class="pl-en">onload</span> <span class="pl-k">=</span> <span class="pl-k">function</span>() {</span>
<span class="pl-s1">      <span class="pl-c"><span class="pl-c">//</span> 1、获取按钮，绑定点击事件</span></span>
<span class="pl-s1">      <span class="pl-k">var</span> myThrottle <span class="pl-k">=</span> <span class="pl-c1">document</span>.<span class="pl-c1">getElementById</span>(<span class="pl-s"><span class="pl-pds">"</span>throttle<span class="pl-pds">"</span></span>);</span>
<span class="pl-s1">      <span class="pl-smi">myThrottle</span>.<span class="pl-c1">addEventListener</span>(<span class="pl-s"><span class="pl-pds">"</span>click<span class="pl-pds">"</span></span>, <span class="pl-en">throttle</span>(sayThrottle));</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c"><span class="pl-c">//</span> 2、节流函数体</span></span>
<span class="pl-s1">    <span class="pl-k">function</span> <span class="pl-en">throttle</span>(<span class="pl-smi">fn</span>) {</span>
<span class="pl-s1">      <span class="pl-c"><span class="pl-c">//</span> 4、通过闭包保存一个标记</span></span>
<span class="pl-s1">      <span class="pl-k">let</span> canRun <span class="pl-k">=</span> <span class="pl-c1">true</span>;</span>
<span class="pl-s1">      <span class="pl-k">return</span> <span class="pl-k">function</span>() {</span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 5、在函数开头判断标志是否为 true，不为 true 则中断函数</span></span>
<span class="pl-s1">        <span class="pl-k">if</span>(<span class="pl-k">!</span>canRun) {</span>
<span class="pl-s1">          <span class="pl-k">return</span>;</span>
<span class="pl-s1">        }</span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 6、将 canRun 设置为 false，防止执行之前再被执行</span></span>
<span class="pl-s1">        canRun <span class="pl-k">=</span> <span class="pl-c1">false</span>;</span>
<span class="pl-s1">        <span class="pl-c"><span class="pl-c">//</span> 7、定时器</span></span>
<span class="pl-s1">        <span class="pl-c1">setTimeout</span>( () <span class="pl-k">=&gt;</span> {</span>
<span class="pl-s1">          <span class="pl-smi">fn</span>.<span class="pl-c1">call</span>(<span class="pl-c1">this</span>, <span class="pl-c1">arguments</span>);</span>
<span class="pl-s1">          <span class="pl-c"><span class="pl-c">//</span> 8、执行完事件（比如调用完接口）之后，重新将这个标志设置为 true</span></span>
<span class="pl-s1">          canRun <span class="pl-k">=</span> <span class="pl-c1">true</span>;</span>
<span class="pl-s1">        }, <span class="pl-c1">1000</span>);</span>
<span class="pl-s1">      };</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">    <span class="pl-c"><span class="pl-c">//</span> 3、需要节流的事件</span></span>
<span class="pl-s1">    <span class="pl-k">function</span> <span class="pl-en">sayThrottle</span>() {</span>
<span class="pl-s1">      <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">"</span>节流成功！<span class="pl-pds">"</span></span>);</span>
<span class="pl-s1">    }</span>
<span class="pl-s1"></span>
<span class="pl-s1">  </span>&lt;/<span class="pl-ent">script</span>&gt;
&lt;/<span class="pl-ent">body</span>&gt;
&lt;/<span class="pl-ent">html</span>&gt;</pre></div>
<p>很好，看完代码的小伙伴应该大致清楚是怎么回事了，下面我们看 GIF 实现：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-2.gif"><img src="assets/1553242691-e7776afea78d7f8b8374610d7c910f90.gif" alt="图" style="max-width:100%;"></a></p>
<p>看完代码和 GIF 实现，我们可以明白，节流即是：</p>
<ul>
<li><strong>节流</strong>：<strong>指定时间间隔内只会执行一次任务。</strong></li>
</ul>
<p>那么，节流在工作中的应用？</p>
<ol>
<li>懒加载要监听计算滚动条的位置，使用节流按一定时间的频率获取。</li>
<li>用户点击提交按钮，假设我们知道接口大致的返回时间的情况下，我们使用节流，只允许一定时间内点击一次。</li>
</ol>
<p>这样，在某些特定的工作场景，我们就可以使用防抖与节流来减少不必要的损耗。</p>
<p>那么问题来了，假设面试官听到你这句话，是不是会接着问一句：“为什么说上面的场景不节制会造成过多损耗呢？”</p>
<p>OK，这就涉及到浏览器渲染页面的机制了……</p>
<h2><a id="user-content-四-重绘与回流" class="anchor" aria-hidden="true" href="#%E5%9B%9B-%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81"></a><a name="user-content-chapter-four" id="user-content-chapter-four">四 重绘与回流</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p>在说浏览器渲染页面之前，我们需要先了解两个点，一个叫 <strong>浏览器解析 URL</strong>，另一个就是本章节将涉及的 <strong>重绘与回流</strong>：</p>
<ul>
<li><strong>重绘(repaint)</strong>：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此<strong>损耗较少</strong>。</li>
</ul>
<p>常见的<strong>重绘</strong>操作有：</p>
<ol>
<li>改变元素颜色</li>
<li>改变元素背景色</li>
<li>more ……</li>
</ol>
<ul>
<li><strong>回流(reflow)</strong>：又叫重排（layout）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</li>
</ul>
<p>常见的<strong>回流</strong>操作有：</p>
<ol>
<li>页面初次渲染</li>
<li>浏览器窗口大小改变</li>
<li>元素尺寸/位置/内容发生改变</li>
<li>元素字体大小变化</li>
<li>添加或者删除可见的 DOM 元素</li>
<li>激活 CSS 伪类（:hover……）</li>
<li>more ……</li>
</ol>
<ul>
<li><strong>重点</strong>：<strong>回流必定会触发重绘，重绘不一定会触发回流。重绘的开销较小，回流的代价较高。</strong></li>
</ul>
<p>看到这里，小伙伴们可能有点懵逼，你刚刚还跟我讲着 <strong>防抖与节流</strong> ，怎么一下子跳到 <strong>重绘与回流</strong> 了？</p>
<p>OK，卖个关子，先看下面场景：</p>
<ul>
<li>界面上有个 div 框，用户可以在 input 框中输入 div 框的一些信息，例如宽、高等，输入完毕立即改变属性。但是，因为改变之后还要随时存储到数据库中，所以需要调用接口。如果不加限制……</li>
</ul>
<p>看到这里，小伙伴们可以将一些字眼结合起来了：为什么需要 <strong>节流</strong>，因为有些事情会造成浏览器的 <strong>回流</strong>，而 <strong>回流</strong> 会使浏览器开销增大，所以我们通过 <strong>节流</strong> 来防止这种增大浏览器开销的事情。</p>
<p>形象地用图来说明：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-3.png"><img src="assets/1553242691-bd932337d650514e1a4745612252c9ab.png" alt="图" style="max-width:100%;"></a></p>
<p>这样，我们就可以形象的将 <strong>防抖与节流</strong> 与 <strong>重绘与回流</strong> 结合起来记忆起来。</p>
<p>那么，在工作中我们要如何避免大量使用重绘与回流呢？：</p>
<ol>
<li>避免频繁操作样式，可汇总后统一一次修改</li>
<li>尽量使用 class 进行样式修改，而不是直接操作样式</li>
<li>减少 DOM 的操作，可使用字符串一次性插入</li>
</ol>
<p>OK，至此我们就讲完两个部分了，那么问题又来了：“浏览器渲染过程中，是不是也有重绘与回流？”“从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？”</p>
<p>我们，继续深入探索……</p>
<h2><a id="user-content-五-浏览器解析-url" class="anchor" aria-hidden="true" href="#%E4%BA%94-%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90-url"></a><a name="user-content-chapter-five" id="user-content-chapter-five">五 浏览器解析 URL</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p>为了能让我们的知识层面看起来更有深度，我们应该考虑下面两个问题了：</p>
<ul>
<li>从浏览器输入 URL 到渲染成功的过程中，究竟发生了什么？</li>
<li>浏览器渲染过程中，发生了什么，是不是也有重绘与回流？</li>
</ul>
<p>OK，兴致来了，我们就先从 <strong>浏览器解析 URL</strong> 看起，先来看看当用户输入 URL，到浏览器呈现给用户页面，经历了以下过程：</p>
<ul>
<li><strong>版本 A</strong>：</li>
</ul>
<ol>
<li>用户输入 URL 地址。</li>
<li>对 URL 地址进行 DNS 域名解析。</li>
<li>建立 TCP 连接（三次握手）。</li>
<li>浏览器发起 HTTP 请求报文。</li>
<li>服务器返回 HTTP 响应报文。</li>
<li>关闭 TCP 连接（四次挥手）。</li>
<li>浏览器解析文档资源并渲染页面。</li>
</ol>
<p>讲到这里，突然想起一个对话：</p>
<p><strong>学生</strong>：“老师，这门课的考试重点是什么？”</p>
<p><strong>老师</strong>：“全都是重点！”</p>
<p>enm...老师会不会被打我不知道，但是 <strong>jsliang</strong> 这样写会被怼我就清楚，所以，咱还是结合上面的图，进一步勾勒我们的结构：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-4.png"><img src="assets/1553242691-73cef929b1dda627850e7cb9a5c02e43.png" alt="图" style="max-width:100%;"></a></p>
<p>很好，<strong>jsliang</strong> 感觉自己的画图技术又进了一步~</p>
<blockquote>
<p>①：虽然很感激网上有那么多的文章可以参考，但是在我查了二十来篇文章后，<strong>jsliang</strong> 觉得这部分十有八九有问题撒，问了些小伙伴，它们有的说对，有的说错。不过，不妨碍小伙伴们继续往下看哈。<br>
②：为了避免出篓子，下面贴出另外一个版本，小伙伴们可以在评论区说出你支持哪个版本哈：</p>
<ul>
<li><strong>版本 B</strong></li>
</ul>
<ol>
<li>用户输入 URL 地址。</li>
<li>对 URL 地址进行 DNS 域名解析。</li>
<li>进行 TCP 连接。</li>
<li>进行 HTTP 报文的请求与响应。</li>
<li>浏览器解析文档资源并渲染页面。</li>
</ol>
</blockquote>
<p>在这里我们可以清晰的了解到从 <strong>用户输入 URL，到浏览器呈现给用户页面，经历了哪些过程</strong>。</p>
<p>那么剩下的就简单了：</p>
<ol>
<li>什么是 DNS 解析，它是怎么个流程？</li>
<li>什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？</li>
<li>浏览器解析文档资源并渲染页面是个怎样的流程？</li>
</ol>
<p>Let's go~ 逐步完成下面三个知识点！</p>
<blockquote>
<p>参考文献 1：<a href="https://www.cnblogs.com/wpshan/p/6282061.html" rel="nofollow">《网页解析的全过程(输入url到展示页面)》</a><br>
参考文献 2：<a href="https://www.jianshu.com/p/32ca5f1c0768" rel="nofollow">《浏览器渲染页面过程剖析》</a></p>
</blockquote>
<h2><a id="user-content-六-dns-域名解析" class="anchor" aria-hidden="true" href="#%E5%85%AD-dns-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90"></a><a name="user-content-chapter-six" id="user-content-chapter-six">六 DNS 域名解析</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p><strong>首先</strong>，我们解决第一个问题：</p>
<ul>
<li>什么是 DNS 解析，它是怎么个流程？</li>
</ul>
<p>DNS（Domain Name System）是 <strong>域名系统</strong> 的英文缩写，提供的服务是用于将主机名和域名转换为 IP 地址的工作：</p>
<p>域名：<code>http://jsliang.top</code> &lt;---&gt; DNS &lt;---&gt; IPV4：<code>119.147.15.13</code></p>
<blockquote>
<p>IPV4 是造假的，仅用来说明 DNS 解析后能返回 IP 地址</p>
</blockquote>
<p>所以，当用户在浏览器输入 <code>http://jsliang.top</code> 时，DNS 经历了以下步骤：</p>
<ol>
<li>浏览器根据地址，在自身缓存中查找 DNS（域名服务器） 中的解析记录。如果存在，则直接返回 IP 地址；如果不存在，则查找操作系统中的 hosts 文件是否有该域名的 DNS 解析记录，如果有就返回。</li>
<li>在条件 1 中的浏览器缓存或者操作系统的 hosts 文件中都没有这个域名的 DNS 解析记录，或者已经过期，则向域名服务器发起请求解析这个域名。</li>
<li>先向本地域名服务器中请求，让它解析这个域名，如果解析不了，则向根域名服务器请求解析。</li>
<li>根服务器给本地域名服务器返回一个主域名服务器。</li>
<li>本地域名服务器向主域名服务器发起解析请求。</li>
<li>主域名服务器接收到解析请求后，查找并返回域名对应的域名服务器的地址。</li>
<li>域名服务器会查询存储的域名和 IP 的映射关系表，返回目标 IP 记录以及一个 TTL（Time To Live）值。</li>
<li>本地域名服务器接收到 IP 和 TTL 值，进行缓存，缓存的时间由 TTL 值控制。</li>
<li>将解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。</li>
</ol>
<p>看文字总是难以理解的，跟着 <strong>jsliang</strong> 画张图过一遍，就感觉清晰了：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-5.png"><img src="assets/1553242691-8015bf5794443035d74f6e30eb1864ab.png" alt="图" style="max-width:100%;"></a></p>
<h2><a id="user-content-七-tcp-三次握手与四次挥手" class="anchor" aria-hidden="true" href="#%E4%B8%83-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"></a><a name="user-content-chapter-seven" id="user-content-chapter-seven">七 TCP 三次握手与四次挥手</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p><strong>然后</strong>，我们解决第二个问题：</p>
<ul>
<li>什么是 TCP 三次握手，什么是 TCP 四次挥手，它们的流程是怎样的？</li>
</ul>
<p>什么是 TCP 呢？TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。</p>
<p>简单来说，它的作用就是将数据流从一台主机可靠地传输到另一台主机。</p>
<p>至于具体的工作原理，这里暂时涉及不到，我们目前只想知道两个点：<strong>三次握手与四次挥手</strong>。</p>
<ul>
<li><strong>三次握手</strong>：</li>
</ul>
<ol>
<li><strong>第一次握手</strong>：起初两端都处于 CLOSED 关闭状态，Client 将标志位 SYN 置为 1，随机产生一个值 <code>seq = x</code>，并将该数据包发送给 Server，Client 进入 SYN-SENT 状态，等待 Server 确认。</li>
<li><strong>第二次握手</strong>：Server 收到数据包后由标志位 <code>SYN = 1</code> 得知 Client 请求建立连接，Server 将标志位 SYN 和 ACK 都置为 1，<code>ack = x + 1</code>，随机产生一个值 <code>seq = y</code>，并将该数据包发送给Client以确认连接请求，Server 进入 <code>SYN-RCVD</code> 状态，此时操作系统为该 TCP 连接分配 TCP 缓存和变量。</li>
<li><strong>第三次握手</strong>：Client 收到确认后，检查 seq 是否为 <code>x + 1</code>，ACK 是否为 1，如果正确则将标志位 ACK 置为 1，<code>ack = y + 1</code>，并且此时操作系统为该 TCP 连接分配 TCP 缓存和变量，并将该数据包发送给 Server，Server 检查 ack 是否为 <code>y + 1</code>，ACK 是否为 1，如果正确则连接建立成功，Client 和 Server 进入 established 状态，完成三次握手，随后 Client 和 Server 就可以开始传输数据。</li>
</ol>
<p>文字太乱，show you picture：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-6.png"><img src="assets/1553242691-6f137d7839740e547ad3fafa247ed897.png" alt="图" style="max-width:100%;"></a></p>
<ul>
<li><strong>四次挥手</strong>：</li>
</ul>
<ol>
<li><strong>第一次挥手</strong>：Client 的应用进程先向其 TCP 发出连接释放报文段（<code>FIN = 1</code>，序号 <code>seq = u</code>），并停止再发送数据，主动关闭 TCP 连接，进入 FIN-WAIT-1（终止等待1）状态，等待 Server 的确认。</li>
<li><strong>第二次挥手</strong>：Server 收到连接释放报文段后即发出确认报文段，（<code>ACK = 1</code>，确认号 <code>ack = u + 1</code>，序号 <code>seq = v</code>），Server 进入 CLOSE-WAIT（关闭等待）状态，此时的 TCP 处于半关闭状态，Client 到 Server 的连接释放。</li>
</ol>
<blockquote>
<p>注：Client 收到 Server 的确认后，进入 FIN-WAIT-2（终止等待2）状态，等待 Server 发出的连接释放报文段。</p>
</blockquote>
<ol start="3">
<li><strong>第三次挥手</strong>：Server 已经没有要向 Client 发出的数据了，Server 发出连接释放报文段（<code>FIN = 1</code>，<code>ACK = 1</code>，序号 <code>seq = w</code>，确认号 <code>ack = u + 1</code>），Server 进入 LAST-ACK（最后确认）状态，等待 Client 的确认。</li>
<li><strong>第四次挥手</strong>：Client 收到 Server 的连接释放报文段后，对此发出确认报文段（<code>ACK = 1</code>，<code>seq = u + 1</code>，<code>ack = w + 1</code>），Client 进入 TIME-WAIT（时间等待）状态。此时 TCP 未释放掉，需要经过时间等待计时器设置的时间 2MSL 后，Client 才进入 CLOSED 状态。</li>
</ol>
<p>文字太乱，show you picture：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-interview-debounce&amp;throttle-7.png"><img src="assets/1553242691-5938c52b69755b1a35dfb9f21a861e5c.png" alt="图" style="max-width:100%;"></a></p>
<p>OK，至此我们就理解了 <strong>TCP 及其三次握手和四次挥手过程</strong>，为了方便小伙伴们形象记忆，<strong>jsliang</strong> 搞了个小故事，希望小伙伴们能加深印象：</p>
<ul>
<li><strong>三次握手 + 四次挥手形象记忆</strong>：</li>
</ul>
<ol>
<li><strong>jsliang</strong>：（对妹子发起微信好友申请）“你好，我可以加你好友吗？” —— <strong>第一次握手</strong></li>
<li><strong>妹子</strong>：（通过审核）“你好，很高兴认识你~” —— <strong>第二次握手</strong></li>
<li><strong>jsliang</strong>：“你好，我叫梁峻荣，前端折腾小能手……” —— <strong>第三次握手</strong></li>
<li>……（聊天内容）</li>
<li>…………（聊天内容）</li>
<li>………………（聊天内容）</li>
<li>…………（聊天内容）</li>
<li>……（聊天内容）</li>
<li><strong>jsliang</strong>：（感冒拍了张纸篓都是纸巾的图）“啊，好难受今天。” —— <strong>第一次挥手</strong></li>
<li><strong>妹子</strong>：“卧槽，你好恶心！” —— <strong>第二次挥手</strong></li>
<li><strong>妹子</strong>：“咱还是当不认识吧，互删了，谢谢！” —— <strong>第三次挥手</strong></li>
<li><strong>jsliang</strong>：（呆）“不是，你听我说！” —— <strong>第四次挥手</strong></li>
<li><strong>妹子</strong>：（果断删除好友） —— <strong>CLOSED</strong></li>
<li><strong>jsliang</strong>：（！“我今天感冒了。” 妹子开启了好友验证，你还不是她好友。请先发送好友验证请求，对方验证通过后，才能聊天。） ——— <strong>CLOSED</strong></li>
</ol>
<p>OK，成功出糗，相信小伙伴们有了个很好的了解了。</p>
<p>那么，我们继续前行探索。</p>
<blockquote>
<p>参考文献 1：<a href="https://www.cnblogs.com/Andya/p/7272462.html" rel="nofollow">《TCP三次握手和四次挥手过程》</a><br>
参考文献 2：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" rel="nofollow">《TCP的三次握手与四次挥手（详解+动图）》</a></p>
</blockquote>
<h2><a id="user-content-八-浏览器渲染页面" class="anchor" aria-hidden="true" href="#%E5%85%AB-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2"></a><a name="user-content-chapter-eight" id="user-content-chapter-eight">八 浏览器渲染页面</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p><strong>最后</strong>，我们解决第三个问题：</p>
<ul>
<li>浏览器解析文档资源并渲染页面是个怎样的流程？</li>
</ul>
<p>话不多说，一起来看：</p>
<ol>
<li>浏览器通过 HTMLParser 根据深度遍历的原则把 HTML 解析成 DOM Tree。</li>
<li>浏览器通过 CSSParser 将 CSS 解析成 CSS Rule Tree（CSSOM Tree）。</li>
<li>浏览器将 JavaScript 通过 DOM API 或者 CSSOM API 将 JS 代码解析并应用到布局中，按要求呈现响应的结果。</li>
<li>根据 DOM 树和 CSSOM 树来构造 render Tree。</li>
<li>layout：重排（也可以叫回流），当 render tree 中任一节点的几何尺寸发生改变，render tree 就会重新布局，重新来计算所有节点在屏幕的位置。</li>
<li>repaint：重绘，当 render tree 中任一元素样式属性（几何尺寸没改变）发生改变时，render tree 都会重新画，比如字体颜色，背景等变化。</li>
<li>paint：遍历 render tree，并调动硬件图形 API 来绘制每个节点。</li>
</ol>
<p>文字讲解肯定还是不够清晰的，但是 <strong>jsliang</strong> 画了几张图也累了，所以咱们 <strong>盗</strong> 来了一张图：</p>
<p><a target="_blank" rel="noopener noreferrer" href="https://github.com/LiangJunrong/document-library/blob/master/public-repertory/img/other-InterviewPreparation-01.png"><img src="assets/1553242691-b176409d514a423a2489b5b942d1c702.png" alt="图" style="max-width:100%;"></a></p>
<p>这样，我们就对 <strong>浏览器渲染页面过程</strong> 一清二楚啦~</p>
<blockquote>
<p>参考文献：<a href="https://juejin.im/post/5bbaa549e51d450e827b6b13" rel="nofollow">《一篇文章搞定前端面试》</a></p>
</blockquote>
<h2><a id="user-content-九-总结" class="anchor" aria-hidden="true" href="#%E4%B9%9D-%E6%80%BB%E7%BB%93"></a><a name="user-content-chapter-night" id="user-content-chapter-night">九 总结</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<p>至此，我们回顾下自己做了什么？</p>
<ol>
<li>我们在工作中碰到一些问题，这些问题会卡住页面，于是我们查资料，知道想要减少浏览器的开销，我们就需要使用 <strong>防抖与节流</strong>。</li>
<li>使用 <strong>防抖与节流</strong> 解决完问题后，我们好奇为什么会有这样的操作，于是我们深入了解了下 <strong>重绘与回流</strong>。</li>
<li><strong>重绘与回流</strong> 只告诉了我们浏览器在 CSS 上的渲染，我们需要进一步了解 <strong>浏览器渲染页面</strong> 的详细过程，但洋葱还是要一层一层剥开的，所以我们需要从 <strong>浏览器解析 URL</strong> 开始了解。</li>
<li>在 <strong>浏览器解析 URL</strong> 中，我们顺带了解下 <strong>DNS 域名解析</strong>、<strong>TCP 三次握手与四次挥手</strong> 这两个知识点。</li>
<li>最后，我们终于知道了 <strong>浏览器渲染页面</strong> 是怎么一回事。</li>
</ol>
<p>综上，如果我们仅仅是需要关注面试的一个点，我们很可能因为不知头尾，而被面试官问得哑口无言。</p>
<p>但是，如果我们知道一个知识点，并对其进行思路发散，深入学习，相信面试官问起来的时候，小伙伴们就可以侃侃而谈，而不会被问地体无完肤了！</p>
<p>最后祝小伙伴们找到合适的满意的工作~</p>
<h2><a id="user-content-十-参考文献" class="anchor" aria-hidden="true" href="#%E5%8D%81-%E5%8F%82%E8%80%83%E6%96%87%E7%8C%AE"></a><a name="user-content-chapter-ten" id="user-content-chapter-ten">十 参考文献</a></h2>
<blockquote>
<p><a href="#chapter-one">返回目录</a></p>
</blockquote>
<ol>
<li><a href="https://www.jianshu.com/p/c8b86b09daf0" rel="nofollow">《函数防抖和节流》</a></li>
<li><a href="https://qishaoxuan.github.io/blog/js/throttleDebounce.html?tdsourcetag=s_pctim_aiomsg" rel="nofollow">《节流 &amp; 防抖》</a></li>
<li><a href="https://www.cnblogs.com/chenqf/p/7986725.html" rel="nofollow">《JS奇淫巧技：防抖函数与节流函数》</a></li>
<li><a href="https://www.cnblogs.com/alai88/p/5518441.html" rel="nofollow">《闲聊 JS 中的 apply 和 call》</a></li>
<li><a href="https://www.cnblogs.com/LMJBlogs/p/6024148.html" rel="nofollow">《js 中 arguments 的用法》</a></li>
<li><a href="https://www.codercto.com/a/35263.html" rel="nofollow">《防抖和节流的应用场景和实现》</a></li>
<li><a href="https://www.cnblogs.com/wpshan/p/6282061.html" rel="nofollow">《网页解析的全过程(输入url到展示页面)》</a></li>
<li><a href="https://www.jianshu.com/p/32ca5f1c0768" rel="nofollow">《浏览器渲染页面过程剖析》</a></li>
<li><a href="https://juejin.im/post/5bbaa549e51d450e827b6b13" rel="nofollow">《一篇文章搞定前端面试》</a></li>
</ol>
<hr>
<blockquote>
<p><strong>jsliang</strong> 广告推送：<br>
也许小伙伴想了解下云服务器<br>
或者小伙伴想买一台云服务器<br>
或者小伙伴需要续费云服务器<br>
欢迎点击 <strong><a href="https://github.com/LiangJunrong/document-library/blob/master/other-library/Monologue/%E7%A8%B3%E9%A3%9F%E8%89%B0%E9%9A%BE.md">云服务器推广</a></strong> 查看！</p>
</blockquote>
<p><a href="https://promotion.aliyun.com/ntms/act/qwbk.html?userCode=w7hismrh" rel="nofollow"><img src="assets/1553242691-ff877879eb2a9da0d4cef0fb0a09f2ae.jpg" alt="图" style="max-width:100%;"></a>
<a href="https://cloud.tencent.com/redirect.php?redirect=1014&amp;cps_key=49f647c99fce1a9f0b4e1eeb1be484c9&amp;from=console" rel="nofollow"><img src="assets/1553242691-735023862c0a2203eabcae975b81d163.jpg" alt="图" style="max-width:100%;"></a></p>
<blockquote>
<p><a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow"><img alt="知识共享许可协议" src="assets/1553242691-9ec05786b815f11908d92ac59b3dc873.png" data-canonical-src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" style="max-width:100%;"></a><br><span>jsliang 的文档库</span> 由 <a href="https://github.com/LiangJunrong/document-library">梁峻荣</a> 采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">知识共享 署名-非商业性使用-相同方式共享 4.0 国际 许可协议</a>进行许可。<br>基于<a href="https://github.com/LiangJunrong/document-library"></a><a href="https://github.com/LiangJunrong/document-library">https://github.com/LiangJunrong/document-library</a>上的作品创作。<br>本许可协议授权之外的使用权限可以从 <a href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="nofollow"></a><a href="https://creativecommons.org/licenses/by-nc-sa/2.5/cn/" rel="nofollow">https://creativecommons.org/licenses/by-nc-sa/2.5/cn/</a> 处获得。</p>
</blockquote>
</article></DIV></DIV></DIV></DIV></MAIN></DIV></DIV>
      
        <hr />
        <!-- clipping information -->
        <div class="clipping-information">
          <label>原网址: <a href="https://github.com/LiangJunrong/document-library/blob/master/other-library/Interview/PersonalExperience/JS-%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81.md" target="_blank" referrerpolicy="no-referrer" rel="noopener noreferrer">访问</a></label><br />
          <label>创建于: 2019-03-22 16:18:11</label><br />
          <label>目录: default</label><br />
          <label>标签: 无</label>
        </div>
    </div>
  </body>
</html>